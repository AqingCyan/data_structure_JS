## 冒泡排序
- 比较相邻的元素。 如果第一个比第二个大，就交换他们两个。
- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。 这步做完后，最后的元素会是最大的数。
- 针对所有的元素重复以上的步骤，除了最后一个。
- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
## 插入排序
- 通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
- 插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。
## 希尔排序
> 希尔排序实际上是对插入排序的一种改进版本

假设有这样一组数[12, 14, 94, 33, 82, 25, 59, 94, 65, 23, 45, 27, 73, 25, 39, 10]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中
来更好地描述算法，这样他们就应该看起来是这样（竖着的元素是步长组成的）
```
12 14 94 33 82
25 59 94 65 23
45 27 73 25 39
10
```
然后我们对每列进行排序：
```
10 14 73 25 23
12 27 94 33 39
25 59 94 65 82
45
```
将上诉四行数字一次拼接在一起，得到[10,14,73,25,23,12,27,94,33,39,25,59,94,65,82,45]。此时10已结到了正确位置，再以3为步长进行排序。
```
10 14 73
25 23 13
27 94 33
39 25 59
94 65 82
45
```
然后我们再对每列进行排序
```
10 14 13
25 23 33
27 25 59
39 65 73
45 94 82
94
```
将上诉数字拼接在一起，得到[10, 14, 13, 25, 23, 33, 27, 25, 59, 39, 65, 73, 45, 94, 82, 94]，再把步长设为2，。。。
最后就能得到排序好的数组
