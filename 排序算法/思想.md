## 冒泡排序
- 比较相邻的元素。 如果第一个比第二个大，就交换他们两个。
- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。 这步做完后，最后的元素会是最大的数。
- 针对所有的元素重复以上的步骤，除了最后一个。
- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
## 插入排序
- 通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
- 插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。
## 希尔排序
> 希尔排序实际上是对插入排序的一种改进版本

假设有这样一组数[12, 14, 94, 33, 82, 25, 59, 94, 65, 23, 45, 27, 73, 25, 39, 10]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中
来更好地描述算法，这样他们就应该看起来是这样（竖着的元素是步长组成的）
```
12 14 94 33 82
25 59 94 65 23
45 27 73 25 39
10
```
然后我们对每列进行排序：
```
10 14 73 25 23
12 27 94 33 39
25 59 94 65 82
45
```
将上诉四行数字一次拼接在一起，得到[10,14,73,25,23,12,27,94,33,39,25,59,94,65,82,45]。此时10已结到了正确位置，再以3为步长进行排序。
```
10 14 73
25 23 13
27 94 33
39 25 59
94 65 82
45
```
然后我们再对每列进行排序
```
10 14 13
25 23 33
27 25 59
39 65 73
45 94 82
94
```
将上诉数字拼接在一起，得到[10, 14, 13, 25, 23, 33, 27, 25, 59, 39, 65, 73, 45, 94, 82, 94]，再把步长设为2，。。。
最后就能得到排序好的数组
## 快速排序
采用两个游标，一个low游标，一个height游标，假设数组开头元素是54，low游标经过的元素都比54小，height游标经过的位置都比54大，当两个游标交汇的时候，
就是54这个元素排序好后的位置。
- 第一个元素，low游标往后移动，若发现该元素比第一个元素小，继续往后移动
- 若移动到一个元素比第一个元素大，把该元素放到height游标所指位置，height游标往前移动，遇到比第一个元素小的，就把该元素放到low游标所指的位置
- 直到两个游标交汇同一位置，此时low游标之前的元素都比第一个元素小，height游标之后的元素都比第一个元素大，那么该游标指向就是第一个元素排序好后的位置
- 此时以该交汇处的左边为一部分，右边为一部分，每一部分进行同样的操作，再分部分，再进行同样操作。

## 归并排序
> 分割：递归地把当前序列平均分割成两半。集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并）。

1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4. 重复步骤3直到某一指针到达序列尾
5. 将另一序列剩下的所有元素直接复制到合并序列尾

![归并排序示意](../book/img/Merge-sort-example.gif)